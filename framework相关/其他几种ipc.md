## 1、管道

数据从写入端（fd[1]）流入管道，然后从读取端（fd[0]）流出。

### 匿名管道

它的数据流向是单向的，是最简单的管道，没有名字，只能存在于具有亲缘关系的进程中，即父与子或兄弟进程

### 命名管道

它可以允许两个不想关进程之间进行通信，它的数据流向也是单向的

## 2、socket

这里了解的是Zygote进程和AMS之间的通信流程：

Zygote 进程启动后，会创建一个 **Unix Domain Socket**（是一种在**同一台主机**上的进程之间进行通信的机制） 并监听来自系统其他部分的命令，主要是来自 AMS 的启动新应用程序的请求。

- zygote作为socket的服务器

  Zygote 在这个 Socket 上监听进入的连接请求。这个 Socket 充当了 Zygote 与系统其他部分（主要是 AMS）进行通信的命令通道。

- ActivityManagerService (AMS) 作为 Socket 客户端：

  当系统需要启动一个新的应用程序时（例如，用户点击了应用图标），`ActivityManagerService` 会作为客户端连接到 Zygote 进程的 Unix Domain Socket。

- 命令的解析

  zygote 进程接收到来自 AMS 的命令后，会解析这些命令和参数。

- 通信的关闭
  完成了fork之后就会关闭连接



这里简单说明下为什么zygote不用binder而是采用socket？

zygote的职责是作为应用进程的“孵化器”，fork创建的子进程几乎完全相同于父进程的副本。

binder通信太复杂了，不仅有线程池，还有代理对象等等。

如果zygote作为一个binder的服务端，后面fork子进程的时候，把这些东西复制给子进程，会非常复杂且困难。

## 3、共享内存
共享内存是允许多个进程访问同一块物理内存区域的机制。
一旦共享内存区被映射到参与通信的进程中，就可以像访问自己内存一样直接进行读写。

共享区域：操作系统在物理内存中分配一块区域，允许多个进程将其映射到各自的虚拟地址空间
直接访问：映射完成后，进程就可以直接对这块共享内存进行读写
无数据拷贝：相比于其他通信方式，这种方式不存在数据拷贝，效率是最高的
但是很重要的一个原因就是共享内存本身不提供任何内置的同步机制。
如果多个进程同时进行读写操作，就会出现数据不一致的问题，必须配合其他的同步问题处理方式。



